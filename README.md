# Видача решти: Жадібний алгоритм vs Динамічне програмування

## Жадібний алгоритм (`find_coins_greedy`)
- Працює швидко (O(n), де n — кількість номіналів)
- Завжди обирає найбільший можливий номінал на кожному кроці
- Ефективний, якщо номінали "добре підібрані" (як у прикладі з 50, 25, 10, 5, 2, 1)
- **Може давати неоптимальний результат**, якщо номінали підібрані погано

## Динамічне програмування (`find_min_coins`)
- Шукає **оптимальне рішення** — мінімальна кількість монет
- Складність: O(n * k), де n — кількість монет, k — сума
- Підходить для довільних наборів номіналів
- Повільніший, особливо для великих сум

## Висновки:
- Для **реальних валют**, жадібний алгоритм зазвичай достатній і набагато швидший.
- Для **нестандартних монет** або вимоги мінімальної кількості монет — потрібне динамічне програмування.
